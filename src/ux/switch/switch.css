.u-switch {
  vertical-align: bottom;
  align-items: flex-start;
}

/* Styling the toggle switch for consistent positioning during DOM update interruptions. */
.u-switch::part(switch) {
  flex-shrink: 0;
}

.u-switch.checked::part(switch-toggle) {
  left: 0%;
  transform: translateX(20px);
}

/* Styling the checked switch when the widget is in an invalid state. */
.u-switch.u-invalid.checked::part(switch),
.u-switch.u-format-invalid.checked::part(switch) {
  --accent-fill-rest: #d13438;
}

.u-switch.u-invalid.checked:hover::part(switch),
.u-switch.u-format-invalid.checked:hover::part(switch) {
  --accent-fill-hover: #d83435;
}

.u-switch.u-invalid.checked:active::part(switch),
.u-switch.u-format-invalid.checked:active::part(switch) {
  --accent-fill-active: #dd4c4c;
}

/* Styling the unchecked switch when the widget is in an invalid state. */
.u-switch.u-invalid::part(switch),
.u-switch.u-format-invalid::part(switch) {
  --neutral-stroke-strong-rest: #d13438;
}

.u-switch.u-invalid:hover::part(switch),
.u-switch.u-format-invalid:hover::part(switch) {
  --neutral-stroke-strong-hover: #d13438;
}

.u-switch.u-invalid:active::part(switch),
.u-switch.u-format-invalid:active::part(switch) {
  --neutral-stroke-strong-active: #d13438;
}

/* Styling the unchecked switch toggle when the widget is in an invalid state. */
.u-switch.u-invalid:not(.checked)::part(switch-toggle),
.u-switch.u-format-invalid:not(.checked)::part(switch-toggle) {
  --neutral-foreground-rest: #d13438;
}

.u-switch::part(error) {
  order: 2; /* The error-icon should always be positioned between the label and the switch control. */
  cursor: pointer;
}

/* Styling the error icon and line height (according to the fluent design system) when the widget is in invalid state. */
.u-switch.u-invalid::part(error),
.u-switch.u-format-invalid::part(error) {
  --type-ramp-base-line-height: 18px;
  color: #d13438;
}

/* Styling the error icon when the switch is in disabled or readonly state */
.u-switch.readonly::part(error),
.u-switch.disabled::part(error) {
  cursor: not-allowed;
}

/* To ensure no margin right is applied when label is empty. */
.u-switch::part(label) {
  margin-inline-end: unset;
}

.u-switch[u-label-position="before"]::part(switch), /* When label position is before, switch control should be at the very end. */
.u-switch[u-label-position="after"]::part(label) { /* When label position is after, label should be at the very end. */
  order: 3;
}

.u-switch[u-label-position="after"]::part(switch), /* When label position is after, switch control should be at the start. */
.u-switch[u-label-position="before"]::part(label) { /* When label position is before, label should be at the start. */
  order: 1;
}

/* When label position is before in flex and grid layouts, the label slot should grow to fill the available space. */
.u-switch[u-label-position="before"]:has(.u-label-text:not([hidden]))::part(label) {
  flex-grow: 1;
}

/* Adding space between label and error-icon when label position is before. */
.u-switch[u-label-position="before"] .u-label-text:not([hidden]) {
  margin-inline-end: calc(var(--design-unit) * 2px + 2px);
}

/* Adding space between error-icon and label when label position is after. */
.u-switch[u-label-position="after"] .u-label-text:not([hidden]) {
  margin-inline-start: calc(var(--design-unit) * 2px + 2px);
}

/* Adding space between error-icon and the switch control when label position is before. */
.u-switch[u-label-position="before"] .u-error-icon {
  margin-inline-end: calc(var(--design-unit) * 2px + 2px);
}

/* Adding space between error-icon/checked/un-checked messages and the label when label position is after. */
.u-switch[u-label-position="after"] .u-error-icon,
.u-switch[u-label-position="after"] .u-checked-message,
.u-switch[u-label-position="after"] .u-unchecked-message {
  margin-inline-start: calc(var(--design-unit) * 2px + 2px);
}

/* The checked/un-checked message should be positioned between the switch control and the label when label position is after. */
.u-switch[u-label-position="after"]::part(status-message) {
  order: 2;
}

/* The checked/un-checked message should be positioned at the very end (after the control) when label position is before. */
.u-switch[u-label-position="before"]::part(status-message) {
  order: 4;
}

/* When there is an overflow, checked/un-checked messages should be shown with ellipses. */
.u-switch::part(checked-message),
.u-switch::part(unchecked-message) {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

/* If either checked or un-checked message is not empty, reserve a specific width. */
.u-switch:has(.u-checked-message:not(:empty))::part(status-message),
.u-switch:has(.u-unchecked-message:not(:empty))::part(status-message) {
  width: 12ch;
}

/* If switch is in invalid state, do not show checked or unchecked messages. */
.u-switch.u-invalid .u-checked-message,
.u-switch.u-format-invalid .u-checked-message,
.u-switch.u-invalid .u-unchecked-message,
.u-switch.u-format-invalid .u-unchecked-message {
  display: none;
}